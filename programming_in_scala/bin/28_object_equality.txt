Describe <tt>hashCode()</tt> contract.<br>	If two objects are <tt>equal()</tt> they must have the same <tt>hashCode()</tt>.<br>
When is there no need to create <tt>canEqual</tt> method?<br>	If the class is final and inherits equals from <tt>Any</tt>. There is no issue of subtype equality in this case.<br>
Why not force <tt>equals()</tt> symmetry by checking the equality of runtime classes?<br>	Anonymous class instances won't be equal to non-anonymous ones.<br><br>In general, subtypes won't be able to equal supertypes.<br>
Other than Java interop, what is a common use of existential types?<br>	Ignoring type parameters with <tt>MyClass[_]</tt> notation.<br><br>e.g., <tt>Map[_,_]</tt><br>
Give the <tt>hashCode()</tt> recipe.<br>	<pre>41* (<br>  41* (<br>    41* (<br>      41 + a.hashCode<br>    ) + b.hashCode<br>  ) + c.hashCode<br>) + d.hashCode<br></pre>
What is your <tt>hashCode()</tt> only good as?<br>Since ___ is not great by default, what should you use?<br>	It's only as good as the hash codes you make it out of.<br><br>For example, most collections override <tt>hashCode</tt> for you, but Arrays do not.<br><br>For <tt>Arrays</tt>, has each element or use <tt>java.util.Arrays.hashCode</tt>.<br>
Why is 41 used in <tt>hashCode</tt> recipe?<br>	Mult: odd primes minimize the potential for information loss on overflow.<br><br>Add: avoid the first field being zero, assuming zero is more likely than -41. Any non-zero integer is equally good.<br>
What are the equivalence relation <tt>equals()</tt> requirements for non-null objects?<br>	- Reflexive<br>- Symmetric<br>- Transitive<br>- Consistent: provided info used by equals was not modified<br>- Not <tt>equal()</tt> to null<br>
Give some common <tt>equals()</tt> pitfalls.<br>	- Defining <tt>equals()</tt> with wrong signature.<br>- Changing <tt>equals()</tt> without changing <tt>hashCode()</tt>.<br>- Defining <tt>equals()</tt> in terms of mutable fields.<br>- Failing to define <tt>equals()</tt> as an equivalence relation.<br>
Give the <tt>equals()</tt> recipe.<br>	<pre>class X extends Y {<br>  def canEqual(other:Any) : Boolean = {<br>    other.isInstanceOf[X]}<br>override def equals(other:Any) : Boolean =<br>  other match {<br>    case that: X => {super.equals(that) &&<br>    (that canEqual this) && fields match }<br>    case _ => false<br>if extending AnyRef no super call,<br>}<br></pre>
What should you do if your <tt>hashCode()</tt> invokes <tt>super.hashCode()</tt>?<br>	Start your <tt>hashCode()</tt> with that invocation.<br><pre>41 * (<br>  super.hashCode()<br>  ) + a.hashCode()<br>) + b.hashCode()<br></pre>
Describe efficient <tt>hashCode</tt>.<br>	For immutable objects, override <tt>hashCode</tt> with similarly named val.<br><br>For mutable objects, use caching.<br>
What is a common source of <tt>equals()</tt> methods that are not equivalence relations?<br>	Subtypes.<br><br>Say A extends B.<br><br><tt>val a = new A ; val b = new B</tt><br><br>"a equals b" and "b equals a" use different versions of equals! So just overriding A's is insufficient.<br>
What's an apparent inconsistency with Java's <tt>equals()</tt>?<br>	Scala's takes Any instead of <tt>AnyRef</tt>/<tt>Object</tt>.<br><br>It's just a fiction of the compiler; it's the same method.<br>
What is <tt>Any</tt>'s <tt>==</tt> defined as?<br>	<pre>final def == (that:Any) : Boolean =<br>  if (null eq this) {null eq that}<br>  else {this equals that}<br></pre>
