What is the difference between built-in control structures and curried function control abstractions?	The curried function requires a function argument of the appropriate type.
Describe currying and its use.	A curried function takes multiple argument lists. It is used for creating control abstractions that feel like native language support.
What is the simplest way to use ScalaTest?	Extend <tt>arg.scalatest.Suite</tt>.<br><br>Start method names with "test" and use assertions or exceptions in them.<br><br>Invoke <tt>execute()</tt> on it or use the provided Runner application.
Give another strategy for giving custom control abstraction a native feel.	Use the by-name parameter instead of function as final argument list.<br><br><pre>def byNameAssert(predicate: => Boolean)=<br>  if (assertionsEnabled && !predicate)<br>    throw new AssertionError</pre><br>If assertions are off, the predicate will never be evaluated and its side effects will never be seen.
Describe higher-order functions and their uses.	They are functions that take functions as parameters.<br><br>They enable the creation of control structures to eliminate duplication of code and simplify client code.
Give custom control abstractions a native feel.	Method calls with one arg can use curlies instead of parens, then you can curry away other args, leaving function as the final parameter.<br><br><pre>withPrintWriter(file){<br>  writer => writer.println(new Date)<br>}</pre>
Get a reference to a curried function's "second" function.<br><br>And its "first" function.	<pre>def curriedSum(x:Int)(y:Int) = x+y<br><br>val onePlus = curriedSum(1)_<br><br>onePlus(2) = 3</pre><br>No space is needed before _ because ( is not a legal identifier.<br><br><tt>val onePlus = curriedSum(_:Int)(1)</tt>
How do you pass method names as values in Scala?	It is not allowed, as it is in dynamic languages.<br><br>The same effect is achieved with function values.
Give an example of a loan pattern.	<pre>def withPrintWriter(file:File)(op:PrintWriter => Unit) {<br>  val writer = new PrintWriter(file)<br>  try {<br>    op(writer)<br>  } finally {<br>    writer.close()<br>    }<br>}</pre>
