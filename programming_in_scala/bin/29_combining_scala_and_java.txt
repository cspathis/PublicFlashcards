Give prettier syntax for existential types.<br>	Use placeholders.<br><br>_ in place of a type makes an existential type just as in place of expression makes a function literal. Each _ is a new existential type.<br><pre>Iterator[_ <: Component]<br>Iterator[T] for Some {type T <: Component}<br></pre>
Make new Java annotations for Java interop.<br>	It must be done using Java notation and compiled with <tt>javac</tt>.<br>
How does Scala deal with Java's wildcard types?<br>	By using existential types, a fully supported part of the language in practice used only for Java compatibility.<br>
Translate to Scala:<br><tt>Iterator <?></tt><br><tt>Iterator<? extends Component></tt><br>	<pre>Iterator[T] for Some {type T}<br>Iterator[T] for Some {type T <: Component}<br></pre>
Why can existential types be ignored most of the time?<br>	Scala can check program soundness even though types and values in forSome clause are unknown.<br>e.g., <tt>val contents = (new JavaClass).contents</tt> is fine even if <tt>JavaClass.contents</tt> is <tt>Collection<?></tt>.<br>
What are singleton objects implemented as?<br>	A combination of static and instance methods.<br><br>They use a class called <tt>ObjectName$</tt> with one instance stored as <tt>MODULE$</tt> field.<br><br>If it's standalone, it will create <tt>ObjectName</tt> class with static forwarder methods for each singleton method.<br>
What does Scala do with Java annotations?<br>	It forwards them on to Java bytecode.<br>
How does Scala get away with not adding thrown exceptions to method bytecode signatures?<br>	The Java bytecode verifier does not check the declarations, only <tt>javac</tt> does in source code.<br>
What does the <tt>javap</tt> output <tt>public static {}</tt> mean?<br>	It indicates the presence of a static initializer block.<br>
Give two strategies for getting around the existential type no-name problem.<br>	- When passing existential type to a method, move type parameters from forSome clause to type parameter of the method. Then in the method body it has a name.<br>- Instead of returning existential type from method, return an object that has abstract members for each part of forSome clause.<br>
When is scala throws declaration bytecode generated?<br>	Only when <tt>@throws</tt> annotation is used for Java compatibility.<br><br><tt>@throws(classOf[IOException])</tt><br>
Implement a trait in Java.<br>	It's generally not practical.<br><br>If the scala trait has only abstract methods, however, it will be translated directly to a Java interface and can be implemented in Java.<br>
What makes existential types awkward? Provide an example.<br>	There is no way to name the existential type.<br><br>e.g., how would one parameterize <tt>Set.empty[??]</tt> if you had taken advantage of Scala's ability to ignore most existential types from Java?<br>
Give the general syntax of existential types.<br>	<tt>type forSome {declarations}</tt><br>where type is some arbitrary Scala type and declarations is a list of abstract vals and types.<br>
