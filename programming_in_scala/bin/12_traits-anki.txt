What's the general rule for mix in order?	Traits further to the right take effect first. If that method calls super, it invokes the method to its left, and so on.
What do stackable modifications allow?<br><br>What is a consequence?	They allow modification of a class's behavior by one or more traits without defining a new version of the class via overridden methods in the class body.<br><br>Hence the modified class may well have no body. The trait does all the modification for you.
Give the mix in syntax.	<tt>class X extends someClass with Trait 1 with Trait 2...</tt><br>or<br><tt>class X extends Trait 1</tt><br>or<br><tt>class X extends Trait 1 with Trait 2</tt>
What is the shortest class definition?	<tt>classX</tt>
What's the main thing you need to know about linearization sequence?	A class is always linearized before <em>all</em> of its superclasses and mixed in traits.<br><br>Thus when you write a method that calls super, the method is definitely modifying the behavior of the superclasses and mixed in traits, not the other way around.
Give two ways traits differ from classes.	- They have class parameters.<br>- Super calls are dynamically instead of statically bound.
Trait vs. mixin	Once a trait is mixed into a class, you can alternatively call it a mixin.
Describe "super" method calls in abstract methods of classes and traits.	In classes this is not allowed because the call will fail at runtime.<br><br>It is allowed in traits with abstract override modifier. Super is dynamically bound so that it will work if the mix-in happens after the class or other trait provides the implementation.
Unlike Java interfaces, what can Scala traits do?	- Extend a superclass.<br>- Have method implementations.<br>- Have state.<br>- Have a constructor (sans parameters).
What does the <tt>Ordered[T]</tt> trait get you?	<, >, <=, >=<br><br>You only implement <tt>compare(T)</tt>.<br><br>Returns<br>`x < 0 iff this < that<br>x = 0 iff this == that<br>x > 0 iff this > that`
How do trait superclasses affect client code?	<tt>trait X extends Y</tt> means X can only be mixed into a Y.
What's a major problem in implementing stackable modifications in a multiple inheritance language?	With multiple inheritance, the method super calls can be determined statically. With traits, linearization determines the calls.<br><br>Linearizing classes with traditional multiple inheritance would break with normal static interpretation of super that is otherwise used. Scala can use one strategy for classes and one for traits.
Why can't <tt>Ordered[T]</tt> override <tt>equals()</tt> for you?	Type erasure!<br><br><tt>equals</tt> has to check the type of the argument to see it it's a T, which is not possible?<br><br>This check must be performed because <tt>compare(T)</tt> takes a narrower type than <tt>equals</tt>, in general.
What are some common uses of traits?	They enrich thin interfaces without burdening the client, since most methods can come fully implemented.<br><br>They can define stackable modifications.
How should you choose between traits and classes?	Traits should be the default choice, as they keep open more options.<br><br><pre>abstract class                     | traits<br>---------------------------------------------------------------------------<br>inherit from Java                  | reusable in multiple parts of the<br>	     			               | hierarchy<br>distribute your code in compiled   |<br>form without forcing recompilation | usable from Java if only made of<br>on every add/remove of member	   | abstract methods<br>   	 	       		               |<br>efficiency			               |<br></pre>
