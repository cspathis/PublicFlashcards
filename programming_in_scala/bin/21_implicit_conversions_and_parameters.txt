Explain the One-at-a-Time Rule.<br>How can you circumvent it?<br>	Only one implicit is tried.<br><br><tt>x + y</tt> will never be rewritten.<br><br><tt>convert1(convert2(x)) + y</tt><br><br>Circumvent this with implicits take implicit parameters.<br>
Explain the Explicits-First Rule.<br>Give a corollary.<br>	Whenever code type checks as it is written, no implicits are attempted.<br><br>Corollary: you can always replace implicit identifiers with explicit ones to make code longer but clearer.<br>
Explain the Marking Rule.<br>	Only definitions marked implicit are available.<br>
Explain the Non-Ambiguity Rule.<br>	An implicit conversion is only inserted if there is no other possible conversion to insert.<br><br>There is no "best match" rule.<br>
Give the most common reason for using view bounds.<br>	Use when implicit parameter is never explicitly used in method body, but only present to introduce implicit conversion ability to body.<br><br><pre>def maxList[T] (elements: List[T])<br>  (implicit orderer: T => Ordered[T]):T<br>def maxList[T <% Ordered[T]]<br>  (elements: List[T]):T<br></pre>
Why do implicit conversion methods have names?<br>	- Explicit invocation.<br>- Selectively importing one conversion method but not another.<br>
What does Scope Rule help with?<br>	Modular reasoning. You only need to consider code that is imported or explicitly referenced through a fully qualified name.<br>
Give the most common use of implicit parameters.<br>	They provide information about a type mentioned explicitly in the earlier parameter list.<br>
What is the fundamental difference between implicit and 2.8's default parameters?<br>What's the consequence?<br>	Default arguments are controlled at the point of definition.<br><br>Implicit parameters are chosen at the point of use and, as such, cannot be called in short form without the implicit being defined.<br>
Give some tips for debugging implicits.<br>	- Try using conversions explicitly to get a new error message or to establish scoping problem.<br><br>- Use <tt>-Xprint:typer</tt> option to see your code after its implicits have been expanded.<br>
Where are implicits tried?<br>	- Conversion to an expected type (e.g. to match a parameter).<br>- Conversions of the receiver of a selection (e.g., "abc".exists(...)`).<br>- Implicit parameters.<br>
Give the convention for libraries providing implicit conversions.<br>	<pre>Preamble object.<br>import Preamble._<br></pre>
Where can implicit keyword be used?<br>	Any variable, function, or object definition.<br>
Describe the Scope Rule.<br>	An inserted implicit conversion must be in scope as a single identifier or be associated with the source or target type of the conversion.<br><br>"Associated with" means found in the companion object of.<br>
Describe the style rule for implicit parameters.<br>	Use at least one role-determining name within the type of an implicit parameter.<br>Bad:<br><tt>(implicit orderer: (T,T) => Boolean)</tt><br>Good:<br><tt>(implicit orderer: T => Ordered[T])</tt><br><br>Preferred Prompt, not String.<br>
Give the two main uses of implicit receiver conversion.<br>	- Integrating a new class into an existing class hierarchy.<br>- Creating DSLs, syntax-like extensions. You can't add your new "syntax" (e.g. <tt>-></tt>) to <tt>Any</tt><br>
Return fixed elements along with variable part using <tt>unapplySeq</tt>.<br>	Return <tt>Option [TupleN]</tt> for some N, since <tt>Tuple</tt> is a <tt>Seq</tt>.<br><br>For example, return<br><tt>Option[(String,Seq[String])]</tt><br>
