What's the general rule for mix in order?<br>	Traits further to the right take effect first. If that method calls super, it invokes the method to its left, and so on.<br>
What do stackable modifications allow?<br>What is a consequence?<br>	They allow modification of a class's behavior by one or more traits without defining a new version of the class via overridden methods in the class body.<br><br>Hence the modified class may well have no body. The trait does all the modification for you.<br>
Give the mix in syntax.<br>	<tt>class X extends someClass with Trait 1 with Trait 2...</tt><br>or<br><tt>class X extends Trait 1</tt><br>or<br><tt>class X extends Trait 1 with Trait 2</tt><br>
What is the shortest class definition?<br>	<tt>classX</tt><br>
What's the main thing you need to know about linearization sequence?<br>	A class is always linearized before <em>all</em> of its superclasses and mixed in traits.<br><br>Thus when you write a method that calls super, the method is definitely modifying the behavior of the superclasses and mixed in traits, not the other way around.<br>
Give two ways traits differ from classes.<br>	- They have class parameters.<br>- Super calls are dynamically instead of statically bound.<br>
Trait vs. mixin<br>	Once a trait is mixed into a class, you can alternatively call it a mixin.<br>
Describe "super" method calls in abstract methods of classes and traits.<br>	In classes this is not allowed because the call will fail at runtime.<br><br>It is allowed in traits with abstract override modifier. Super is dynamically bound so that it will work if the mix-in happens after the class or other trait provides the implementation.<br>
Unlike Java interfaces, what can Scala traits do?<br>	- Extend a superclass.<br>- Have method implementations.<br>- Have state.<br>- Have a constructor (sans parameters).<br>
What does the <tt>Ordered[T]</tt> trait get you?<br>	<, >, <=, >=<br><br>You only implement <tt>compare(T)</tt>.<br><br>Returns<br>`x < 0 iff this < that<br>x = 0 iff this == that<br>x > 0 iff this > that`<br>
How do trait superclasses affect client code?<br>	<tt>trait X extends Y</tt> means X can only be mixed into a Y.<br>
What's a major problem in implementing stackable modifications in a multiple inheritance language?<br>	With multiple inheritance, the method super calls can be determined statically. With traits, linearization determines the calls.<br><br>Linearizing classes with traditional multiple inheritance would break with normal static interpretation of super that is otherwise used. Scala can use one strategy for classes and one for traits.<br>
Why can't <tt>Ordered[T]</tt> override <tt>equals()</tt> for you?<br>	Type erasure!<br><br><tt>equals</tt> has to check the type of the argument to see it it's a T, which is not possible?<br><br>This check must be performed because <tt>compare(T)</tt> takes a narrower type than <tt>equals</tt>, in general.<br>
What are some common uses of traits?<br>	They enrich thin interfaces without burdening the client, since most methods can come fully implemented.<br><br>They can define stackable modifications.<br>
How should you choose between traits and classes?<br>	Traits should be the default choice, as they keep open more options.<br><br><pre>abstract class                     | traits<br>---------------------------------------------------------------------------<br>inherit from Java                  | reusable in multiple parts of the<br>	     			               | hierarchy<br>distribute your code in compiled   |<br>form without forcing recompilation | usable from Java if only made of<br>on every add/remove of member	   | abstract methods<br>   	 	       		               |<br>efficiency			               |<br></pre>
