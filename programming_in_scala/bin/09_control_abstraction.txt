What is the difference between built-in control structures and curried function control abstractions?<br>	The curried function requires a function argument of the appropriate type.<br>
Describe currying and its use.<br>	A curried function takes multiple argument lists. It is used for creating control abstractions that feel like native language support.<br>
What is the simplest way to use ScalaTest?<br>	Extend <tt>arg.scalatest.Suite</tt>.<br><br>Start method names with "test" and use assertions or exceptions in them.<br><br>Invoke <tt>execute()</tt> on it or use the provided Runner application.<br>
Give another strategy for giving custom control abstraction a native feel.<br>	Use the by-name parameter instead of function as final argument list.<br><br><pre>def byNameAssert(predicate: => Boolean)=<br>  if (assertionsEnabled && !predicate)<br>    throw new AssertionError<br></pre><br>If assertions are off, the predicate will never be evaluated and its side effects will never be seen.<br>
Describe higher-order functions and their uses.<br>	They are functions that take functions as parameters.<br><br>They enable the creation of control structures to eliminate duplication of code and simplify client code.<br>
Give custom control abstractions a native feel.<br>	Method calls with one arg can use curlies instead of parens, then you can curry away other args, leaving function as the final parameter.<br><br><pre>withPrintWriter(file){<br>  writer => writer.println(new Date)<br>}<br></pre>
Get a reference to a curried function's "second" function.<br>And its "first" function.<br>	<pre>def curriedSum(x:Int)(y:Int) = x+y<br>val onePlus = curriedSum(1)_<br>onePlus(2) = 3<br></pre><br>No space is needed before _ because ( is not a legal identifier.<br><br><tt>val onePlus = curriedSum(_:Int)(1)</tt><br>
How do you pass method names as values in Scala?<br>	It is not allowed, as it is in dynamic languages.<br><br>The same effect is achieved with function values.<br>
Give an example of a loan pattern.<br>	<pre>def withPrintWriter(file:File)(op:PrintWriter => Unit) {<br>  val writer = new PrintWriter(file)<br>  try {<br>    op(writer)<br>  } finally {<br>    writer.close()<br>    }<br>}<br></pre>
