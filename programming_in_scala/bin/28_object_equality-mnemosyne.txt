Describe <tt>hashCode()</tt> contract.	If two objects are <tt>equal()</tt> they must have the same <tt>hashCode()</tt>.
When is there no need to create <tt>canEqual</tt> method?	If the class is final and inherits equals from <tt>Any</tt>. There is no issue of subtype equality in this case.
Why not force <tt>equals()</tt> symmetry by checking the equality of runtime classes?	Anonymous class instances won't be equal to non-anonymous ones.<br><br>In general, subtypes won't be able to equal supertypes.
Other than Java interop, what is a common use of existential types?	Ignoring type parameters with <tt>MyClass[_]</tt> notation.<br><br>e.g., <tt>Map[_,_]</tt>
Give the <tt>hashCode()</tt> recipe.	<pre>(41* (  41* (    41* (      41 + a.hashCode    ) + b.hashCode  ) + c.hashCode) + d.hashCode,true)</pre>
What is your <tt>hashCode()</tt> only good as?<br><br>Since ___ is not great by default, what should you use?	It's only as good as the hash codes you make it out of.<br><br>For example, most collections override <tt>hashCode</tt> for you, but Arrays do not.<br><br>For <tt>Arrays</tt>, has each element or use <tt>java.util.Arrays.hashCode</tt>.
Why is 41 used in <tt>hashCode</tt> recipe?	Mult: odd primes minimize the potential for information loss on overflow.<br><br>Add: avoid the first field being zero, assuming zero is more likely than -41. Any non-zero integer is equally good.
What are the equivalence relation <tt>equals()</tt> requirements for non-null objects?	- Reflexive<br>- Symmetric<br>- Transitive<br>- Consistent: provided info used by equals was not modified<br>- Not <tt>equal()</tt> to null
Give some common <tt>equals()</tt> pitfalls.	- Defining <tt>equals()</tt> with wrong signature.<br>- Changing <tt>equals()</tt> without changing <tt>hashCode()</tt>.<br>- Defining <tt>equals()</tt> in terms of mutable fields.<br>- Failing to define <tt>equals()</tt> as an equivalence relation.
Give the <tt>equals()</tt> recipe.	<pre>(class X extends Y {  def canEqual(other:Any) : Boolean = {    other.isInstanceOf[X]}override def equals(other:Any) : Boolean =  other match {    case that: X => {super.equals(that) &&    (that canEqual this) && fields match }    case _ => falseif extending AnyRef no super call,},true)</pre>
What should you do if your <tt>hashCode()</tt> invokes <tt>super.hashCode()</tt>?	Start your <tt>hashCode()</tt> with that invocation.<br><pre>(41 * (  super.hashCode()  ) + a.hashCode()) + b.hashCode(),true)</pre>
Describe efficient <tt>hashCode</tt>.	For immutable objects, override <tt>hashCode</tt> with similarly named val.<br><br>For mutable objects, use caching.
What is a common source of <tt>equals()</tt> methods that are not equivalence relations?	Subtypes.<br><br>Say A extends B.<br><br><tt>val a = new A ; val b = new B</tt><br><br>"a equals b" and "b equals a" use different versions of equals! So just overriding A's is insufficient.
What's an apparent inconsistency with Java's <tt>equals()</tt>?	Scala's takes Any instead of <tt>AnyRef</tt>/<tt>Object</tt>.<br><br>It's just a fiction of the compiler; it's the same method.
What is <tt>Any</tt>'s <tt>==</tt> defined as?	<pre>(final def == (that:Any) : Boolean =  if (null eq this) {null eq that}  else {this equals that},true)</pre>
