What <em>may</em> make a covariant type unsound?	Generic parameter type may appear as the type of a method parameter.<br><pre>class Queu[+T] {<br>  def append(x:T) =<br>  ...<br>}</pre>
Describe the Liskov Substitution Principle.	If T supports the same operations as U and all of T's operation have less strict requirements and provide more than the corresponding operations in U.<br><br>Then T is a subtype of U and you can substitute a T where a U is required.
Describe a fully persistent data structure.	Old versions remain available even after extensions or modifications.
Give an example of a good candidate for contravariance.	<pre>trait OutputChannel[-T] {<br>  def write(x:T)<br>}</pre><br>It makes sense that <tt>OutputChannel</tt> of <tt>AnyRef</tt> is a subtype of <tt>OutputChannel</tt> of <tt>String</tt> because a class that can write out an <tt>AnyRef</tt> can certainly write out <tt>Strings</tt>. The converse is not true.
Give an example of a good candidate for covariance.	A functional <tt>Queue</tt>.<br><br><pre>class Queue[+T] {<br>  dep append[U>:T] (x:U) :<br>    Queue[U] = ...<br>}</pre>This allows the adding of <tt>Queue[Apple]</tt> and an <tt>Orange</tt> to make a new <tt>Queue[Fruit]</tt>.
Why are Java arrays covariant?	Before Java introduced generics, it was the only way to support method signatures that operated on all types of arrays.<br><br><tt>void sort(Object[]a, Comparator cmp)</tt>
Interact with Java covariant arrays using Scala nonvariant <tt>Arrays</tt>.	Scala lets you cast an array of T to an array of any supertype of T.
Describe variance annotations.	They appear before formal parameter.<br><br><pre>MyClass[-T] contravariant<br>MyClass[T] nonvariant<br>MyClass[+T] covariant</pre>
What are the downsides of Java arrays being covariant?	- Efficiency, type of elements added may be checked against store type.<br>- Storage is not covariant, resulting in runtime <tt>ArrayStoreExceptions</tt> the compiler cannot catch.
Modify visibility of primary constructor.	<pre>class MyClass private (<br>  val param1: Int<br>  val param2: String<br>)</pre>
What's a good use of object private fields?	Escaping the variance checker's usual prohibition on reassignable fields of a covariant parameter.
What does the compiler guarantee regarding variance annotations and usage?<br><br>How so?	Correctness, by classifying all positions in a class as positive, negative, or neutral.<br><br>Nonvariants can be used at all three, covariants at positive only, and contravariants at negative only.
Why doesn't mutable state mesh well with covariance?	If the var is of the covariant type generated, setter and getter have methods with the covariant parameter.
