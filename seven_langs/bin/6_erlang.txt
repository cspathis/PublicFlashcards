How is <em>Erlang</em> pronounced?<br>	AIR-lang<br><br><em>air</em> rhymes with <em>fair</em>.<br><em>lang</em> rhymes with <em>sang</em>.<br>
Why is Erlang growing in popularity?<br>	Concurrency - Erlang eliminates buggy threads, but tries to make processes as lightweight as possible.<br><br>Reliability - Erlang embraces a non-defensive "let it crash" attitude with regard to errors andl offers zero-downtime hot-swapping of code.<br>
What does an actor represent in Erlang?<br>Contrast this with Scala.<br>	- In Scala in actor represents an object. A thread pool backs the running actors, but actors may have to share the same thread.<br>- In Erlang an actor represents a lightweight process. Each actor gets its own process.<br>
How do you make comments?<br>How do you end a statement?<br>	Inline comments begin with a percent sign.<br><br>Statements end with a period.<br>
Lists are formed with ... and tuples with ...<br>What's the difference between them?<br>	... square brackets ... curly brackets.<br><br>Tuples are fixed-length.<br>
How are Erlang variables different from variables in imperative languages?<br>	Erlang variables can only be assigned once.<br>
How are mappings usually expressed in Erlang?<br>	Using tuples.<br><br><pre>> Capital = {capital, {paris, france}}<br>> {capital, {What, france}} = Capital.<br>> What.<br>paris<br></pre>
Why do "map" tuples often begin with an initial atom to identify the relationship?<br>	To allow pattern matching to collect all the mappings of a given type.<br>
What is <tt>=</tt> in Erlang?<br>	Pattern matching, <strong>not</strong> assignment.<br>
What is a key difference between tuples and lists when it comes to pattern matching?<br>	Lists can pattern match against lists of different lengths (using cons). Tuples never can.<br>
How do you prepend to a list?<br>How do you pattern match on a list?<br>	Using the same syntax:<br><br><pre>1> A = [1,2].<br>[1,2]<br>2> B = [0 | A].<br>[0,1,2]<br>3> [First | Rest] = B.<br>[0,1,2]<br>4> First.<br>0<br>5> Rest.<br>[1,2]<br></pre>
What are Erlang binaries?<br>	A collection-like Erlang feature for specifying the number of bits each variable gets.<br><br><pre>Bytes = <<A:2, B:6, C:4, D:4>><br></pre>Means <tt>A</tt> gets 2 bits, <tt>B</tt> gets 6 bits, etc.<br>(Those variables are already bound).<br><br>To extract, use the same syntax:<br><pre><<ABits:2, BBits:6, CBits:4, DBits:4>> = Bytes<br></pre>
What's the conceptual difference between <tt>case</tt> and <tt>if</tt> expressions?<br>	In <tt>case</tt> expressions control flows by pattern matching. In <tt>if</tt> expressions it flows by evaluating Boolean guards.<br>
What function iterates over a list?<br>What's its downside?<br>	`lists:foreach(fun(El) -> ... end, List)<br><br>It results in <tt>ok</tt>, not a useful value.<br>
Why don't <tt>loop()</tt> functions blow up the stack?<br>	They are tail recursive. The last thing any <tt>receive</tt> case should do is call <tt>loop()</tt> afresh. Erlang supports tail-call optimization.<br>
What's the difference between sending and receiving synchronously?<br>How is each conventionally done?<br>	Receiving synchronously involves <tt>receive</tt> clauses that reply to the sender. By convention the PID of the sender should be the first element of a message tuple.<br><br>Send synchronously involves blocking the requester until the reply is ready. By convention the actor module will have a function that takes as its first argument the PID of the instance to send the message to, and the request as the second argument. This function now behaves like a normal, non-blocking function, even though its actually executes in a different process by sending an asynchronous message to the provided PID.<br>
How can you check if a process is alive?<br>	<pre>erlang:is_process_alive(Pid).<br></pre>
How can you create a monitoring process that restarts dead processes?<br>	Create an actor such that:<br>1) The first thing its <tt>loop</tt> function does is trap exit.<br>2) Write a <tt>receive</tt> case for creating a process, and registering it with a meaningful atom name.<br>3) Write a <tt>receive</tt> case for exits which sends a signal to the other case.<br>
