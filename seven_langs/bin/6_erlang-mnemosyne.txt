How is <em>Erlang</em> pronounced?	AIR-lang<br><br><em>air</em> rhymes with <em>fair</em>.<br><em>lang</em> rhymes with <em>sang</em>.
Why is Erlang growing in popularity?	Concurrency - Erlang eliminates buggy threads, but tries to make processes as lightweight as possible.<br><br>Reliability - Erlang embraces a non-defensive "let it crash" attitude with regard to errors andl offers zero-downtime hot-swapping of code.
What does an actor represent in Erlang?<br><br>Contrast this with Scala.	- In Scala in actor represents an object. A thread pool backs the running actors, but actors may have to share the same thread.<br>- In Erlang an actor represents a lightweight process. Each actor gets its own process.
How do you make comments?<br><br>How do you end a statement?	Inline comments begin with a percent sign.<br><br>Statements end with a period.
Lists are formed with ... and tuples with ...<br><br>What's the difference between them?	... square brackets ... curly brackets.<br><br>Tuples are fixed-length.
How are Erlang variables different from variables in imperative languages?	Erlang variables can only be assigned once.
How are mappings usually expressed in Erlang?	Using tuples.<br><br><pre>> Capital = {capital, {paris, france}}<br>> {capital, {What, france}} = Capital.<br>> What.<br>paris<br></pre>
Why do "map" tuples often begin with an initial atom to identify the relationship?	To allow pattern matching to collect all the mappings of a given type.
What is <tt>=</tt> in Erlang?	Pattern matching, <strong>not</strong> assignment.
What is a key difference between tuples and lists when it comes to pattern matching?	Lists can pattern match against lists of different lengths (using cons). Tuples never can.
How do you prepend to a list?<br><br>How do you pattern match on a list?	Using the same syntax:<br><br><pre>1> A = [1,2].<br>[1,2]<br>2> B = [0 | A].<br>[0,1,2]<br>3> [First | Rest] = B.<br>[0,1,2]<br>4> First.<br>0<br>5> Rest.<br>[1,2]<br></pre>
What are Erlang binaries?	A collection-like Erlang feature for specifying the number of bits each variable gets.<br><br><pre>Bytes = <<A:2, B:6, C:4, D:4>><br></pre><br>Means <tt>A</tt> gets 2 bits, <tt>B</tt> gets 6 bits, etc.<br>(Those variables are already bound).<br><br>To extract, use the same syntax:<br><pre><<ABits:2, BBits:6, CBits:4, DBits:4>> = Bytes<br></pre>
What's the conceptual difference between <tt>case</tt> and <tt>if</tt> expressions?	In <tt>case</tt> expressions control flows by pattern matching. In <tt>if</tt> expressions it flows by evaluating Boolean guards.
What function iterates over a list?<br><br>What's its downside?	`lists:foreach(fun(El) -> ... end, List)<br><br>It results in <tt>ok</tt>, not a useful value.
Why don't <tt>loop()</tt> functions blow up the stack?	They are tail recursive. The last thing any <tt>receive</tt> case should do is call <tt>loop()</tt> afresh. Erlang supports tail-call optimization.
What's the difference between sending and receiving synchronously?<br><br>How is each conventionally done?	Receiving synchronously involves <tt>receive</tt> clauses that reply to the sender. By convention the PID of the sender should be the first element of a message tuple.<br><br>Send synchronously involves blocking the requester until the reply is ready. By convention the actor module will have a function that takes as its first argument the PID of the instance to send the message to, and the request as the second argument. This function now behaves like a normal, non-blocking function, even though its actually executes in a different process by sending an asynchronous message to the provided PID.
How can you check if a process is alive?	<pre>erlang:is_process_alive(Pid).<br></pre>
How can you create a monitoring process that restarts dead processes?	Create an actor such that:<br>1) The first thing its <tt>loop</tt> function does is trap exit.<br>2) Write a <tt>receive</tt> case for creating a process, and registering it with a meaningful atom name.<br>3) Write a <tt>receive</tt> case for exits which sends a signal to the other case.
