Why is Prolog a departure from many common languages?<br>	Prolog is <em>declarative</em>, not <em>imperative</em>. You describe logic, not a flow of control.<br>
What are the building blocks of Prolog?<br>	Facts, rules, and queries.<br>
What does the Prolog compiler do?<br>	It compiles facts + rules (together called a <em>knowledge base</em>) to support efficient querying.<br>
What are the Prolog capitalization rules?<br>	If a symbol begins with a lowercase character it's an atom - a fixed value.<br>If it begins with an uppercase character it's a variable.<br>
How do you load a Prolog file?<br>	<pre>['relative/path/file.pl']<br></pre><em>or</em><br><pre>['/absolute/path/to/file.pl']<br></pre>
What do the Prolog replies <tt>yes</tt> and <tt>no</tt> mean?<br>	<tt>yes</tt> means "yes I can prove that" or "yes I know that to be true".<br><br><tt>no</tt> means "no I can't prove that" or "no I don't know that to be true".<br>
How can you make a rule with two variables guaranteed to be distinct?<br>	Use the <tt>\+</tt> predicate, <em>.e.g,</em><br><br><pre>somePred(X, Y) :- \+ (X = Y), someOtherPred(X, Y)<br></pre>
How can you query a knowledge base?<br>	- Type a fact and see if Prolog can prove it.<br>- Type a fact with a variable (conventionally named <tt>What</tt>) to see if Prolog can find bindings that satisfy the fact. Use semicolons (<tt>;</tt>) to ask for another binding, or <tt>a</tt> to get all of them.<br>
How is <tt>=</tt> different in Prolog compared to other languages?<br>	<tt>=</tt> is <strong>not</strong> assignment, it is <em>unification</em>, the attempt to make both sides logically the same.<br>
How is a rule with multiple clauses satisfied?<br>How is a rule with multiple subgoals satisfied?<br>	Only one of the clauses must be satisfied.<br><br>Every subgoal must be satisfied.<br>
How can you get tail-call optimizations in Prolog?<br>	Make your recursive subgoal the last subgoal in a rule.<br>
How can you unpack a list?<br>	<pre>?- [one, two, three, four]= [Head | Tail].<br>Head = one,<br>Tail = [two, three, four].<br></pre>
What kind of problem is ideal for Prolog?<br>	One which has constraints that are easily expressed but difficult to satisfy. Since Prolog figures out the satisfying bindings, Prolog is doing the hard part for you.<br>
What are some areas where Prolog is still used?<br>	- Games<br>- Semantic web<br>- AI and NLP<br>- Scheduling<br>
What are Prolog's weaknesses?<br>	- It's not a general purpose language.<br>- It may not scale due to inefficient DFS approach to unification and heavy use of recursion.<br>
