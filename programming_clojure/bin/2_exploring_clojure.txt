Define <em>homoiconicity</em>.<br>	Wikipedia: a property of some programming languages, in which the primary representation of programs is also a data structure in a primitive type of the language itself.<br><br>"code-as-data"<br>
Describe the Clojure build process.<br>	The reader converts the program text into forms which are then converted into Clojure data structures, which are then compiled.<br>
What are the most common forms?<br>	Boolean, number, string, character, keyword, symbol, nil, vector, list, map.<br>
How are Clojure numbers different from Java's?<br>	- Integers are automatically promoted to arbitrary-size <tt>BigIntegers</tt> as needed.<br>- <tt>BigIntegers</tt> and <tt>BigDecimals</tt> have a literal form, a number ending with <tt>M</tt>.<br>
What can symbols refer to?<br>	Functions with standard identifiers, operators, Java classes, Clojure namespaces, Java packages, data structures, refs.<br>
What are the rules for symbol names?<br>	They may not begin with a number.<br>They consist of letters, numbers, <tt>+</tt>, <tt>-</tt>, <tt>*</tt>, <tt>/</tt>, <tt>?</tt>.<br><br><tt>.</tt> and <tt>_</tt> are also possible, but have special meaning with respect to namespaces.<br>
How are string literals different from Java's?<br>	- They can be multiline.<br>- They are displayed to the screen with escaped newlines.<br>
How are strings different from Java's?<br>	They are sequences of characters, so higher-order sequence functions work on them.<br>
Describe <tt>str</tt>.<br>	It creates a string, much like <tt>toString</tt>, but is n-ary and ignores <tt>nil</tt>.<br>
How are escape characters created?<br>	<tt>\backspace</tt>, <tt>\formfeed</tt>, <tt>\newline</tt>, <tt>\return</tt>, <tt>\space</tt>, <tt>\tab</tt><br>
How can a string be created from a sequence of characters?<br>	<pre>(apply str [\a \b \c])<br></pre><br><tt>apply</tt> is making an n-ary call to <tt>str</tt> given a sequence argument.<br>
How can you test for strict booleans?<br>	Use <tt>true?</tt> and <tt>false?</tt>.<br>
Give two ways to query a map.<br>	- <tt>(map key)</tt><br>- <tt>(keyword-key map)</tt><br><br>Note the second form works only if the key is a keyword.<br>
What are structs used for?<br>	To document the fact that multiple maps are similar, i.e., they share common keys.<br>
What special symbols are used in the documentation?<br>	<tt>&</tt> indicates the following param is of variable arity and available as a seq.<br><tt>*</tt> indicates the previous param is of variable arity.<br><tt>+</tt> indicates the previous param is of variable, non-zero arity.<br><tt>?</tt> indicates the previous param is optional.<br>
Define a struct.<br>Instantiate a struct.<br>	<pre>(defstruct name & keys)<br></pre><br><pre>(struct name & vals)<br></pre>
What is the basis of a struct?<br>	The keys listed in the struct's definition.<br>
How can one create a struct that lacks keys from the basis or has additional keys?<br>	<pre>(struct-map name & inits)<br></pre><br>Any missing keys will be given the value <tt>nil</tt> in the resulting struct.<br>
How are structs different from maps?<br>	The difference is mostly stylistic, although structs do store their values in indexed slots.<br>
What's the difference between a reader macro and a form?<br>	Reader macros are applied prior to the text being broken into forms.<br>
What's the most common reader macro?<br>	The comment, <tt>;</tt>.<br>
Why are programs barred from defining additional reader macros?<br>	To prevent code becoming unreadable to others, and to prevent Clojure from fragmenting into non-interoperable dialects.<br>
How can you test for the type of a form?<br>	Use the built in predicates <tt>keyword?</tt>, <tt>symbol?</tt>, etc.<br>
What is the signature of <tt>defn</tt> with a single param list?<br>	<pre>(defn name doc-string? attr-map? [params*] body)<br></pre>
What is the signature of <tt>defn</tt> with multiple param lists?<br>	<pre>(defn name doc-string? attr-map?<br> ([params*] body)+ )<br></pre>
What is <tt>defn</tt>, really?<br>	A macro for:<br><br><pre>(def name (fn [params*] exprs*))<br></pre><br>The doc-string and attrs are added to the var metadata.<br>
What is the vararg syntax?<br>	Just as in the documentation syntax, use a <tt>&</tt> before the final parameter.<br>
Give non-obvious reasons for using anonymous functions.<br>	- To capture surrounding data in a function created at run-time (i.e., a closure) without giving many different functions the same name.<br>- To avoid a top-level binding for a function used exclusively inside another one.<br>
What is the abbreviation for anonymous functions?<br>How is it implemented?<br>	<pre>(# body)<br></pre>where the arguments are given the names <tt>%1</tt>, <tt>%2</tt>, etc. <tt>%</tt> is the same as <tt>%1</tt>.<br><br>It's a reader macro.<br>
What is a root binding?<br>	The initial value of a var it was given in a <tt>def</tt>/<tt>defn</tt> statement.<br>
How can a <tt>var</tt> be accessed directly, as opposed to its value?<br>	With the reader macro:<br><pre>#'symbol<br></pre><br>for <tt>(var symbol)</tt>.<br>
What can vars do other than store values?<br>	- Store metadata.<br>- Be rebound differently for each thread.<br>- Be aliased for unqualified use in other namespaces.<br>
Which bindings are lexically scoped?<br>	- parameters<br>- <tt>(let [bindings*] exprs*)</tt><br>
Where can destructuring be used?<br>What are the two kinds?<br>	Destructuring can be used in <tt>fn</tt> parameter lists, <tt>let</tt>, and macros that expand to either of those.<br><br>Vectors can be put in the binding to capture sequential collections, or maps for associative collections.<br>
How can you get a reference to the <strong>entire</strong> collection being destructured?<br>	Use <tt>:as name</tt> in the destructuring. It will bind to the entire collection, not just the part being matched.<br>
What makes a collection sequential?<br>	It supports <tt>nth</tt>.<br><br><pre>(coll index not-found?)<br></pre>
Name Clojure's special forms <strong>not</strong> for Java interop.<br>	<tt>def</tt>, <tt>if</tt>, <tt>do</tt>, <tt>let</tt>, <tt>quote</tt>, <tt>var</tt>, <tt>fn</tt>, <tt>loop</tt>, <tt>recur</tt>, <tt>throw</tt>, <tt>try</tt>, <tt>monitor-enter</tt>, <tt>monitor-exit</tt>.<br>
Name Clojure's special forms for Java interop.<br>	<tt>.</tt>, <tt>new</tt>, <tt>set!</tt><br>
Find the fully qualified name of a symbol.<br>Keep in mind ...<br>	<pre>(resolve symbol)<br></pre><br>... typically the symbol must be quoted to prevent evaluation into whatever it refers to.<br>
How do you switch to a new namespce?<br>Create a new namespace?<br>	<pre>(in-ns name)<br></pre>switches to the namespace <tt>name</tt>, creating it if necessary.<br>
What do all namespaces automatically include?<br>What does the <tt>user</tt> namespace bring in?<br>	They include the package <tt>java.lang</tt>.<br><br><tt>user</tt> also brings in <tt>clojure.core</tt>. Otherwise you would run:<br><pre>(clojure.core/use 'clojure.core)<br></pre>
Avoid using the fully qualified names of Java classes.<br>	<pre>(import '(package Class+))<br></pre>
Avoid using the fully qualified names of Clojure vars.<br>	<pre>(use 'clojure.contrib.whatever)<br>(use '[clojure.contrib.whatever :only (func)])<br></pre>
What namespace are you currently in?<br>	It's available as <tt>*ns*</tt>.<br>
Where are imports from Clojure and Java typically done?<br>	In the namespace declaration.<br><br><pre>(ns name & references)<br></pre><br>Each reference can be a <tt>:use</tt> or an <tt>:import</tt>.<br>
What is the purpose of <tt>do</tt>?<br>	It allows you to use multiple expressions where only one is allowed. The last expression is the the result of the whole expression. Previous expressions are executed for side-effects.<br>
Describe <tt>loop</tt>.<br>	It's just the same as <tt>let</tt>, except it introduces a recursion point which <tt>recur</tt> can return to.<br><br><pre>(loop [bindings *] exprs*)<br>(recur exprs*)<br></pre>
Where you can you add metadata?<br>How do you do it?<br>	Metadata can be added to collections and symbols.<br><br><pre>(with-meta object metadata)<br></pre>
What is Clojure's semantic equality test?<br>Reference equality?<br>	<tt>=</tt> is like Java's <tt>equals</tt><br><tt>identical?</tt> is like Java's ==<br>
How is metadata usually accessed?<br>	With the <tt>^</tt> macro.<br><br><tt>^x</tt> is like <tt>(meta x)</tt><br>
Add keys to a map.<br>	<pre>(assoc map k v & more-kvs)<br></pre>
Add <tt>:tag</tt> documentation metadata to a <tt>defn</tt>.<br>	<pre>(defn #^{:tag BigInt} name [#^{:tag BigInt} i] body)<br>(defn #^BigInt name [#^BigInt i] body)<br>(defn name<br>  ([i] body)<br>  {:tag BigInt})<br></pre>
What is the difference between <tt>with-meta</tt> and the <tt>#^</tt> macro?<br>	The reader macro adds metadata directly to a var or parameter.<br><tt>with-meta</tt> adds it to the value.<br>
