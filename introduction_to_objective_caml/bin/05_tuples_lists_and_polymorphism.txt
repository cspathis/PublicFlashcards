How does OCaml support parametric polymorphism?<br>	Expressions can have types that include type variables, standing for an arbitrary type.<br>
How are type variables written?<br>	Lowercase identifiers starting with a lowercase letter prefixed by an apostrophe.<br>
Add type annotations to a function declaration.<br>	<pre>let funcname (p1 : pt1) ... (pn : ptn) : rest = ...<br></pre><br>The parens are essential.<br>
What is the <em>value restriction</em>?<br>	The requirement that only immutable values can be truly polymorphic.<br><br>That means the expression is fully evaluated (including the binding of type variables) and cannot be modified through assignment.<br>
What is the type of an expression that is a composition of truly polymorphic parts?<br>	If the type variables are not bound in the expression they become unknown types, written <tt>'_a</tt>. They represent a <em>single</em> still-unknown type. Hence the resulting expression is not truly polymorphic.<br>
Unless otherwise stated <em>values</em> are ...<br>	immutable values.<br>
What is the purpose of the value restriction?<br>	To preserve correct typing in a language that allows side-effects.<br>
Why can't function application result in a polymorphic type?<br>	There is no mechanism for controlling purity of the function being applied.<br>
How can one circumvent the value restriction?<br>	Use <em>eta expansion</em>, the creation of an anonymous function that wraps the desired expression.<br><br><pre>fun p -> someExpression p<br></pre>
Why doesn't OCaml provide overloading?<br>	- It complicates type inference. Some method will be needed for identifying the correct function in an expression that can uses overloaded functions ambiguously. That method may be uncomputable.<br>- Programmer confusion.<br>
How are tuples written?<br>And their types?<br>	Comma-separated values, not necessarily surrounded by parens.<br><br>The types are written <tt>*</tt>-separated.<br>
What is <em>destructuring</em>?<br>Demonstrate on tuples.<br>	Decomposition of an aggregate type using pattern matching.<br><br><pre># let a, b = 1, 2;;<br>val a : int = 1<br>val b : int = 2<br></pre>
Access the elements of a tuple.<br>	- Use pattern matching.<br>- For a 2-tuple use <tt>fst</tt> and <tt>snd</tt>.<br>
How are lists written?<br>	<tt>;</tt>-separated values surrounded by square brackets.<br>
How is the <em>cons</em> operator used?<br>	Both to prepend to a list and to pattern match the head of a list.<br>
How are parameterized types written?<br>	With the type parameter preceding the main type.<br><br><pre>string list<br>'a list (* polymorphic *)<br></pre>
What is an association list?<br>How is it queried?<br>	A list of pairs, used as a simple associative map.<br><br><pre>List.assoc 'a -> ('a * 'b)<br></pre>looks for the associated element or raises <tt>Not_found</tt>.<br>
What is <em>tail recursion</em>?<br>Why is it desirable?<br>	A function is tail recursive if all recursive calls are returned by the function without any additional computation.<br><br>Tail recursive functions are preferred over general recursive functions as they can be optimized by the compiler to avoid consuming additional stack space. (They are rewritten as loops).<br>
List accumulator values in recursive functions are best built ...<br>	... in reverse, to benefit from constant-time cons.<br><br>The final result will be reversed with <tt>List.rev</tt>.<br>
