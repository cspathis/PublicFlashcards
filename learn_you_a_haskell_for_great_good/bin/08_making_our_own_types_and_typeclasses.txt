What is the basic syntax of the <tt>data</tt> keyword?<br>	<pre>data TypeName = ValueConstructorA FieldA1 ... FieldAN | ValueConstructorB ...<br></pre>
What are value constructors, really?<br>What aren't they?<br>	Functions that ultimately return a value of a data type. So the "fields" of a value constructor are really parameters.<br><br>They are <strong>not</strong> types.<br>
Literals can be thought of as what?<br>	Value constructors with no parameters.<br>
How can you make your typeclass inherit another one?<br>	Add <tt>deriving (OtherClass)</tt> to the end of the <tt>data</tt> declaration.<br>
When there's only one value constructor for a type, it's common to do what?<br>	Use the same name for the data type and the value constructor.<br>
How do you export types from a module?<br>	<pre>module MyModule<br>( DataConstructor1(..)<br>, ...<br>, DataConstructorN<br>) where ...<br></pre><br>The <tt>..</tt> indicates all value constructors of the type constructor should be exported.<br>Otherwise you can comma separate the ones you want to export, or leave off the parens altogether to not export any value constructors.<br>
What happens if you don't export any value constructors?<br>Give an example of a standard library type like this.<br>	Instances of the type can be created only through auxiliary functions.<br><br><tt>Data.Map</tt> can be constructed only through auxiliary functions like <tt>fromList</tt>.<br>
What is record syntax?<br>Give its syntax.<br>	A way of creating value constructors with automatic meaningfully named accessors.<br><br><pre>data Person = Person { firstName :: String<br>                     , lastName :: String<br>                     , age :: Int<br>                     , height :: Float<br>                     , phoneNumber :: String<br>                     , flavor :: String<br>                     } deriving (Show)<br></pre>
What use-site convenience does record syntax provide?<br>	Named parameters. Users can invoke the value constructor using curlies and comma-separated named values.<br>
Define <tt>Maybe</tt>.<br>	Like Scala's <tt>Option</tt>:<br><br><pre>data Maybe a = Nothing | Just a<br></pre>
When should you use type parameters?<br>When should you not?<br>	Use them when your type is a container of some kind.<br>Otherwise don't, since your functions on the type will make strong assumptions about the types filled in.<br>
Why is there a strong convention against putting typeclass constraints in data declarations?<br>	Constraints should follow from functions that assume the constraint.<br>If you put the constraint on the data declaration you will have to put the constraint on <strong>all</strong> functions, even when the constraint is irrelevant to that particular function.<br>
What's the catch when deriving <tt>Eq</tt>?<br>	All the field types must also be of the <tt>Eq</tt> typeclass.<br>
What is the default interpretation of deriving <tt>Ord</tt>?<br>	Ordering the value constructors least to greatest, in the order defined.<br>
What is a value constructor with no parameters called?<br>	nullary<br>
What syntactic convenience to <tt>Enums</tt> have?<br>	They can be used in list ranges.<br>
Describe type synonyms?<br>	Haskell's term for Scala's type aliases.<br>The syntax is the same as Scala's:<br><pre>type Name = Type<br></pre>
What abilities do type synonyms have over Scala's type aliases?<br>	Haskell's can be parameterized:<br><pre>type AssocList k v = [(k,v)]<br></pre><br>Haskell's can be "partially applied" using either of these notations:<br><pre>type AssocListInt = AssocList Int<br>type AssocListInt v = AssocList Int v<br></pre>
What is a concrete type?<br>	A type that is fully applied, with no unbound type parameters.<br>
Describe <tt>Either</tt>.<br>What is it used for.<br>	Approximately:<br><pre>data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)<br></pre>Errors use <tt>Left</tt>, successful result uses <tt>Right</tt>.<br><br>Its used for functions that can fail in multiple ways. <tt>Maybe</tt>'s <tt>Nothing</tt> would not inform as to which way it failed.<br>
Demonstrate recursive types by defining <tt>List</tt> with standards syntax.<br>Do the same with record syntax.<br>	<pre>data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)<br>data List a = Empty | Cons { listHead :: a, listTail :: List a} deriving (Show, Read, Eq, Ord)<br></pre>
What is a fixity declaration?<br>Give its syntax.<br>	It indicates which way an operator associates and how tightly.<br><br><pre>fixity num op<br></pre>Where <tt>fixity</tt> is one of <tt>infix</tt>, <tt>infixr</tt>, <tt>infixl</tt>, and <tt>num</tt> is the tightness of binding, and <tt>op</tt> is the operator in question.<br>Larger numbers indicate tighter bindings.<br>
Give the <tt>data</tt> definition of a tree.<br>	<pre>data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)<br></pre>
Give the basic typeclass syntax.<br>	<pre>class ClassName typevar1 ... typevarn where<br>    funcDefOrDeclaration1<br>    ...<br>    funcDefOrDeclarationN<br></pre><br>Function declarations are simply type signatures like <tt>ghci</tt> would put out in response to <tt>:t</tt>.<br>
Manually create an instance of <tt>Eq</tt>.<br>	<pre>instance Eq TrafficLight where<br>    Red == Red = True<br>    Green == Green = True<br>    Yellow == Yellow = True<br>    _ == _ = False<br></pre>
How can a typeclass implement all its functions yet require that instances implement some of them?<br>	The typeclass might implement functions in terms of one another, requiring a minimal complete definition to define one to bootstrap the others.<br>
What is <em>subclassing</em> in Haskell?<br>Given an example.<br>	Adding a class constraint to a <tt>class</tt> declaration.<br><br><pre>class (Eq a) => Num a where<br>    ...<br></pre>
How can you find information about names that aren't expressions?<br>	<tt>:info Name</tt> in <tt>ghci</tt>.<br>
What's the <tt>Functor</tt> typeclass?<br>Give a partial implementation.<br>	It's for things that can be mapped over, like lists.<br><br><pre>class Functor f where<br>    fmap :: (a -> b) -> f a -> f b<br></pre>
What is a <em>kind</em>?<br>How can the be found using <tt>ghci</tt>?<br>	More or less, the type of a type.<br><br><pre>:k Type<br></pre>
