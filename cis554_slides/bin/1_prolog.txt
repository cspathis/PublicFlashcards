What is backwards reasoning?<br>Why does Prolog use it?<br>	Backwards reasoning is from (potential) conclusions to facts instead of from facts to conclusions.<br>Prolog uses it because the space of possible conclusions grows too quickly in the number of premises.<br>
How can you load a Prolog database for interactive use?<br>	You can use the <tt>consult</tt> and <tt>reconsult</tt> predicates, or use bracket notation.<br>Bracket notation allows re-consultation of several files at once:<br><br><pre>['file1.pl', file2.pl']<br></pre>
What is the closed world assumption?<br>	A Prolog database knows everything it needs to know.<br>
What is a structure?<br>	A name followed by zero or more arguments. Parens are omitted if there are no arguments.<br>
What is a base clause?<br>	A structure terminated by a period. It represents a simple fact.<br>
What is a nonbase clause?<br>	A structure followed by a turnstile and a list of structures separated by commas. It represents a rule.<br>
What is a predicate?<br>	A <strong>collection</strong> of clauses with the same <em>functor</em> (name) and arity.<br>
What is a program?<br>	A collection of predicates, in any order.<br>
How can you include special characters and spaces in an atom, or begin it with a capital letter?<br>	Use single quotes, which does <strong>not</strong> make a string.<br>
What are double quotes for?<br>	They indicate a list of ASCII values.<br>
How can you include escape characters in a quoted atom?<br>	Use double quotes or an escaped single quote to use a single quote.<br>Other escapes use backslash as in other languages.<br>
What are the four ports of a structure?<br>	<pre>         -----<br>call --> |   | --> exit<br>fail <-- |   | <-- redo<br>         -----<br></pre><br><tt>exit</tt> ports connect to <tt>call</tt> ports.<br><tt>fail</tt> ports connect to <tt>redo</tt> ports.<br>
Prolog's logic is <em>non-monotonic</em>. What does that mean?<br>	Facts can be added at any time using the <tt>assert</tt> predicate.<br><br>Facts can be removed at any time using the <tt>retract</tt> predicate.<br><br>Such rules are <em>dynamic</em>.<br>
Why might you need to double the parens of a structure?<br>	To force a rule to be interpreted as a single argument, since rules contain commas.<br><br><pre>assert((loves(chuck, X) :- female(X), rich(X))).<br></pre>
What are the limitations of backtracking.<br>	- Output can't be undone.<br>- <tt>assert</tt> and <tt>retract</tt> can't be undone either.<br>
How do you write to stdout?<br>	<tt>write</tt> predicate outputs its single argument to stdout.<br><tt>nl</tt> writes a newline.<br>
How can you view the available facts and rules?<br>How can you view the available structures of a predicate?<br>	<tt>listing(predicate)</tt><br><br><tt>listing</tt><br>
What does a single underscore (<tt>_</tt>) do?<br>	It's an anonymous variable. It can unify with anything.<br>
What's the difference between cut (<tt>!</tt>) and <tt>fail</tt>?<br>	<tt>fail</tt> doesn't force other the entire predicate to fail. Other clauses will be tried.<br><br>Using a cut creates a commit point, preventing backtracking past the commit point and preventing attempts on other clauses.<br>
What happens if you combine cut and fail?<br>	The predicate as a whole fails.<br>
Why might you start a variable with an underscore?<br>	To tell Prolog you are only going to use it once, but don't wish to use the anonymous variable.<br><br>You can still use it again if you really want.<br>
What is the scope of a variable?<br>	For onymous variables, the single clause in which it appears.<br>
What order are clauses of a predicate tried in?<br>	The same order in which they were defined.<br>
What can you use in place of <tt>if</tt>?<br>What can you use in place of loops?<br>	- Predicates with multiple clauses that have "tests" in them.<br>- Recursion.<br>
How can you get around the lack of functions with no return values?<br>	Use a fail loop.<br><br><pre>my_func(X) :-<br>    Some(),<br>    Imperative(),<br>    Calls(),<br>    fail.<br>my_func(_)<br></pre><br>It's generally bad style to do this.<br>
How can you get around the lack of functions with return values?<br>	A parameter (conventionally the final one) of a parameter list can be used for output.<br><br><pre>?- assert((first([Head | Tail], X) :- X = Head)).<br>true.<br>?- first([1,2,3], X).<br>X = 1.<br></pre>
How can you work around the lack of assignable state?<br>	You can store state in the database as facts.<br><br><pre>bump_count :-<br>    retract(count(X)),<br>    Y is X + 1,<br>    assert(count(Y)).<br></pre><br>It's generally bad style to do this.<br>
What is the <tt>=..</tt> operator?<br>	The "univ" operator. It converts between structures and lists.<br><br><pre>loves(chuck, X) =.. [loves, chuck, X]<br></pre>
What predicate describes list membership?<br>What predicate describes combining lists?<br>	<pre>?- member(1, [1, 2]).<br>true .<br></pre><br><pre>?- append([1], [2], [1, 2]).<br>true.<br></pre>
How can you force a predicate to succeed?<br>	Make the final case a "dummy" with no body that uses anonymous variables for all the parameters.<br>
What should you do if you don't care if a call succeeds and don't want failure to cause backtracking?<br>	<pre>wrapper :-<br>    potentially_failing_call.<br>wrapper.<br></pre><br>Now any call to wrapper will succeed.<br>
What are <tt>asserta</tt> and <tt>assertz</tt> for?<br>	They are like <tt>assert</tt>, but <tt>asserta</tt> guarantees the added clause will come before any clauses with the same functor. Likewise <tt>assertz</tt> guarantees the added clause will be the last case in its predicate.<br>
What does <tt>abolish</tt> do?<br>	It removes <em>all</em> clauses of the predicate with the given functor and arity.<br><br><pre>abolish(somePred, arity).<br></pre>
What's the catch with arithmetic in Prolog?<br>	<tt>+</tt>, <tt>-</tt>, <tt>*</tt>, <tt>/</tt>, and <tt>mod</tt> have their normal meanings, but <em>only when evaluated</em>.<br><br>They may not be evaluated when  you want, leading to strange outcomes like:<br><pre>?- 2 + 2 = 4.<br>false.<br></pre>
What is the difference between static and dynamic clauses in SWI Prolog?<br>	Static clauses are the default and cannot be later modified using <tt>assert</tt>/<tt>retract</tt>.<br>Marking clauses <tt>dynamic</tt> (before they are defined) allows you to change the definition during program execution.<br><br><pre>:- dynamic somePredArityTwo/2, somePredArityOne/1.<br></pre><br>To actually force arithmetic to be performed you can use <tt>is</tt> or comparison operators like <tt>=:=</tt>, <tt>=/=</tt>, <tt>></tt>, <tt>>=</tt>, <tt><</tt>, <tt><=</tt>.<br>
What does <tt>var/1</tt> do?<br>	<tt>var(X)</tt> succeeds only if <tt>X</tt> is instantiated to an atom.<br>
