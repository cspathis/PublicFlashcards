How can you compile and load a module into the <tt>erl</tt> shell?<br>	<pre>c(module.erl).<br></pre><br>Now that module's functions can be accessed with:<br><pre>module:func<br></pre>
What do Erlang programs begin with?<br>	<pre>-module(filename).<br></pre><br>... for a program defined in filename.erl.<br>
How can you use methods in other modules without module qualification?<br>	<pre>-import(filename, [func1/arity1, ..., funcN/arityN]).<br></pre>
How can you make your module's functions available to other modules?<br>	<pre>-export(filename, [func1/arity1, ..., funcN/arityN]).<br></pre><br>or<br><br><pre>-compile(export_all).<br></pre>
What are the Erlang case rules?<br>	Similar to Prolog, and Haskell, functions and atoms begin with a lower case, variables begin with a capital letter or an underscore.<br>
What is an atom?<br>What are its lexical rules?<br>	An atom is a word that stands for itself.<br>It begins with a lowercase letter or is enclosed in single quotes.<br>
What are Erlang's primitive data types?<br>	Integers, floats, strings, atoms, lists, tuples, binaries.<br>
How are lists, tuples, and binaries written?<br>	Lists are enclosed in square brackets, tuples in curly brackets, and binaries in double angle brackets.<br>
What's odd about Erlang's Boolean operators?<br>	They don't short-circuit by default. For short-circuiting you have <tt>andalso</tt> and <tt>orelse</tt>.<br>
How are "greater or equal to" and "less than or equal to" expressed?<br>	<tt>>=</tt> and <tt>=<</tt>.<br><strong>not</strong> <tt><=</tt>.<br>
What are the equality operators?<br>How are they used?<br>	<tt>==</tt> equal to<br><tt>/=</tt> not equal to<br><tt>=:=</tt> exactly equal to<br><tt>=/=</tt> not exactly equal to<br><br>The non-exact versions will coerce its into floats. Otherwise use exact versions to give better hints to the compiler.<br>
What is <tt>=</tt> in Erlang?<br>	Pattern matching, not assignment. "Assignment" is just a simple case of pattern matching.<br>
What is the syntax of <tt>case</tt> expressions?<br>	<pre>case Expression of<br>    Pattern1 [when Guard1] -> Expression_sequence1;<br>    ...<br>    PatternN [when GuardN] -> Expression_sequenceN<br>end<br></pre>
What is an expression sequence?<br>What is its value?<br>	A sequence of expressions separated by commas.<br><br>The value of the last expression evaluated.<br>
Give the syntax of <tt>if</tt> expressions.<br>	<pre>if<br>    Guard1 -> Expression_sequence1;<br>    ...<br>    Guard2 -> Expression_sequence2<br>end<br></pre>
What happens if no guard in an <tt>if</tt> expression is true?<br>How can this be avoided.<br>	An error will be returned.<br><br>One can use the <tt>true</tt> atom as the final guard, although it is usually better to use something more explicit than <tt>true</tt> when possible.<br>
What is the huge restriction on guards?<br>	To enforce no-side-effects, they cannot be user-defined.<br><br>You can use type tests, many operators, and a number of built-in functions.<br>
How do you access the length of a list?<br>Of a tuple?<br>	<tt>length(List)</tt><br><br><tt>size(Tuple)</tt><br>
Give the syntax of named functions.<br>	<pre>name(Patterns1) -> Expression_sequence1;<br>...<br>name(PatternsN) -> Expression_sequenceN.<br></pre>
Give the syntax of anonymous functions.<br>What are they often used for?<br>	<pre>fun(Patterns1) -> Body1;<br>    (Patterns2) -> Body2;<br>    ...<br>    (PatternsN) -> BodyN<br>end<br></pre><br>They are often used as parameters to other functions.<br>
Give the syntax of list comprehensions.<br>	<pre>[Expression || Generator, GuardOrGenerator, ..., GuardOrGenerator]<br></pre><br>The expression typically makes use of variables defined by a generator.<br>Guards are simply boolean expressions.<br>Generators are of the form <tt>El <- List</tt>.<br>
Give a generator that doubles the members of a list.<br>	<tt>[X * 2 || X <- [1, 2, 3, 4]]</tt><br>
Which list functions do not need to be imported or qualified?<br>	<tt>hd</tt> (head), <tt>tl</tt> (tail), <tt>length</tt><br>
Create a range of integers.<br>	<pre>lists:seq(From, To)<br>lists:seq(From, To, Step)<br></pre><br>Note: <tt>To</tt> is inclusive, unlike in Scala/Python/etc<br>
Get a line from stdin.<br>Put a line to stdout.<br>	<pre>Line = io:get_line(Prompt).<br></pre><br><pre>io:format(FormatString, ListOfData).<br></pre>
How do you write to a file?<br>	<pre>{ok, Stream} = file:open(FileName, write),<br>io:format(Stream, FormatString, ListOfData),<br>file:close(Stream).<br></pre>
What are the reserved sequences in format strings?<br>	<tt>~s</tt> a string<br><tt>~w</tt> a value in its standard syntax (e.g., strings as lists of integers)<br><tt>~p</tt> a value, pretty printed (e.g., strings with quotes around them)<br><tt>~n</tt> or <tt>\n</tt> newline<br>
What is the comment syntax?<br>	<tt>%</tt> causes the rest of the line to be discarded.<br>
<tt>filter</tt> and <tt>map</tt> take which arguments?<br>	First the function to apply to the members of the list, and then the list.<br>
How can you get truncating division?<br>	<pre>0> 2 rem 3.<br>2<br></pre>
How can you use previously defined functions as parameters to other functions?<br>	Create an anonymous function in-line using the function's full name, <em>funcName/arity</em>.<br>E.g.,<br><br><pre>get_red() -> filter(fun is_red/1, fruit()).<br></pre>
What are strings, really?<br>	Lists of ASCII integer values.<br>
What do <tt>lists:all</tt> and <tt>lists:any</tt> do?<br>	The same as Scala's <tt>forall</tt> and <tt>exists</tt>.<br>
How is Erlang's <tt>zip</tt> more restrictive than other languages'?<br>	The two lists must be of the same length.<br>
Append two lists.<br>	<tt>lists:append([1, 2], [3, 4])</tt><br>or<br><tt>[1, 2] ++ [3, 4]</tt><br>result in<br><br><tt>[1, 2, 3, 4]</tt><br>
What do <tt>takewhile</tt> and <tt>dropwhile</tt> do?<br>	<tt>takewhile</tt> scans through a list until the predicate fails for the first time, at which point it discards the failed element and everything after.<br><br><tt>dropwhile</tt> scans through the list, discarding everything until the predicate holds for the first time.<br>
What does <tt>partition</tt> do?<br>	It creates a tuple of two lists. The first list holds the elements of the input list for which the predicate held, and the second holds the elements for which the predicate failed.<br>
How can  you run code in a new process?<br>	<pre>Pid = spawn(Function)<br></pre>
How can you generate a "return address" to send with your message?<br>	<tt>self()</tt> results in the Pid of the executing process.<br>
Give the syntax of <tt>receive</tt>.<br>	<pre>receive<br>    Pattern1 [when Guard1] -> Expression_sequence1;<br>    ...<br>    PatternN [when GuardN] -> Expression_sequenceN<br>after Timeout -><br>    TimeoutExpressionSequence<br>end<br></pre>
How is Erlang's <tt>loop()</tt> different from Scala's?<br>	<tt>loop</tt> in Scala is a control structure in the actors library that does the looping for you.<br>In Erlang <tt>loop</tt> is just the name of a function you're calling so you must make the recursive call at the end of each <tt>receive</tt> case.<br>
What's an idiomatic way to set up an Erlang remote procedure call server?<br>	Provide a function that takes as an argument the Pid of the instance of the module to send the message to.<br>Send the message there, wait for a response, and then reply.<br><br>Ultimately a user may start several processes, but after that point will interact with the blocking rpc function.<br>
Describe Pid registration.<br>	Registering a Pid makes it globally available.<br><br><tt>register(AnAtom, Pid)</tt> gives <tt>Pid</tt> a name<br><tt>unregister(AnAtom)</tt><br><pre>registered() -> [AnAtom :: atom()]<br></pre>returns a list of all registered processes<br><pre>whereis(AnAtom) -> Pid | undefined<br></pre>gets Pid of a registered process, or undefined if no such process<br>
What's the difference between <tt>spawn</tt> and <tt>spawn_link</tt>?<br>	<tt>spawn</tt> creates a processes independent from the current one.<br><tt>spawn_link</tt> creates a new process linked to the current one, such that if the new process exits non-normally, so will the current one.<br>
How can you introduce/remove links between two running processes?<br>	<tt>link(Pid)</tt> and <tt>unlink(Pid)</tt><br>
How can you terminate the current process?<br>How can you send exit signals <em>without actually exiting</em>?<br>	<tt>exit(Reason)</tt> exits and sends signals to linked processes.<br><br><tt>exit(Pid, Reason</tt> sends the exit signal to the given process, but doesn't terminate the current process.<br>
How can you link to a process while reserving the right to handle the partner process's exit however you like?<br>	<pre>process_flag(trap_exit, true)<br>spawn_link(Function)<br></pre><br>Now exit signals are converted to regular <tt>{'EXIT', From, Reason}</tt> messages.<br>However, if the reason is <tt>kill</tt>, exit will still be forced.<br>
Why isn't <tt>try</tt>/<tt>catch</tt> much used in Erlang?<br>	Crashed processes are normally handled through linking, not in <tt>catch</tt> sequences.<br>
What is a common strategy for making functions tail recursive?<br>	Create a helper function with an additional argument that will serve as an accumulator.<br>
