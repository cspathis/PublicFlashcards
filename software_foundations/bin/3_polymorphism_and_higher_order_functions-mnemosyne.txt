Polymorphic inductive definitions can be thought of as what?	Functions from <tt>Type</tt>s to <tt>Inductive</tt> definitions. Or, since we always use <tt>Inductive</tt> definitions to create types, then a function from <tt>Types</tt> to <tt>Types</tt>.
What are the types of the <em>polymorphic constructors</em> <tt>nil</tt> and <tt>cons</tt>?	<pre>Check nil.<br>===> nil : forall X : Type, list X<br>Check cons.<br>===> cons : forall X : Type, X -> list X -> list X</pre><br>The <tt>forall</tt> portion should be read as an additional argument to the constructor.
With respect to polymorphic inductive types, Coq will automatically infer what?<br><br>What won't Coq automatically infer?	Coq will automatically attempt to infer the types of arguments, even when those types are polymorphic.<br><br>However, Coq won't automatically attempt to infer <em>arguments</em>, for example the <tt>Type</tt> argument to a polymorphic constructor.
How can we avoid writing type arguments in an invocation?<br><br>Throughout a module?<br><br>At declaration site?	At constructor/function invocation:<br><pre>length bool someBoolList<br>length _ someBoolList</pre><br>For the remainder of the module, works on functions or inductive definitions:<br><pre>Implicit Arguments length [[X]].</pre><br>On function declaration site use curlies, which avoids even the need for underscores on use-site:<br><pre>Fixpoint length {X:Type} (l:list X) : nat :=<br>  ...</pre>
How can you use explicit type arguments after having requested inference?Use <tt>@</tt>.	<pre>(* This fails if inference has been requested.*)<br>(* Definition mynil := nil nat *)<br><br>Definition mynil := @nil nat</pre>
What's the difference between <tt>(x,y)</tt> and <tt>(X*Y)</tt>?	<tt>(x,y)</tt> is a 2-tuple <em>value</em>, using special notation.<br><tt>(X*Y)</tt> is its <em>type</em>, also using special notation.<br><br>It just so happens that <tt>x:X</tt> and <tt>y:Y</tt>.
Which way does the type arrow associate?	Right.<br><br>The following two are equivalent:<br><pre>nat -> nat -><br>nat -> (nat -> nat)</pre>
What are the type signatures of currying and uncurrying a function?	Currying:<br><pre>(A * B) -> C<br>A -> B -> C</pre><br>Uncurrying:<br><pre>A -> B -> C<br>(A * B) -> C</pre>
Give the syntax of anonymous functions.	<pre>fun arg1 ... argN => expr</pre>
Define a function that overrides other functions whose domain is <tt>nat</tt>s.<br><br>Give its type.	<pre>Definition override {X:Type} (f: nat =>X) (k:nat) (x:X) : nat->X :=<br>  fun(k':nat) => if beq_nat k k' then x else f k'.</pre><br><pre>===> override : forall X : Type, (nat -> X) -> nat -> X -> nat -> X</pre>
Describe the <tt>unfold</tt> and <tt>fold</tt> tactics.	<tt>unfold</tt> replaces a term with its definitions, "expanding" functions.<br><br><tt>fold</tt> takes the expanded term and packs it back up into a definition. It is much less used.
What does it mean to say that constructors in Coq are <em>disjoint</em>?	Values built from distinct constructors are never equal.
What does it mean to say that constructors in Coq are <em>injective</em>?	The only way for two values produced by a constructor to be equal is for them to have been constructed with the same values as functions.
Describe the <tt>inversion</tt> tactic.	Given a hypothesis <tt>H</tt> in context:<br><pre>c a1 ... an = d b1 ... bn</pre><br><tt>inversion H</tt> will conclude either:<br>- If <tt>c</tt> and  <tt>d</tt> are the same constructor then by the inversion property <tt>ai = bi</tt>. Those facts will be added to the context and will be used to rewrite the goal.<br><br>- If <tt>c</tt> and <tt>d</tt> are different then by disjointness property we have reached contradiction so the current goal is proved, since <em>any</em> goal is now provable.
How can tactics be applied to hypothesis instead of the goal?	Use the <tt>in</tt> keyword.<br><br>For example:<br><pre>simpl in H<br>apply L in H</pre>
Explain the difference between <em>forward</em> and <em>backward</em> reasoning.	Forward reasoning is just modus ponens:<br>Given <tt>L1</tt> and <tt>L1->L2</tt> conclude <tt>L2</tt>.<br>Backward reasoning starts with the goal and reasons about what would imply the goal until a premise or previous theorem is reached.<br>Given <tt>L1->L2</tt> and the <em>goal</em> <tt>L2</tt>, consider it proved if <tt>L1</tt> is already known.
What happens if you <tt>destruct</tt> on an expression instead of a value?	The cases will be equations with the expression and its possible values.<br><br><pre>destruct (beq_nat n 3).<br>  Case "beq_nat n 3 = true". ...<br>  Case "beq_nat n 3 = false". ...</pre>
Explain the <tt>remember</tt> tactic.	?
Explain the <tt>apply ... with ...</tt> tactic.	?
