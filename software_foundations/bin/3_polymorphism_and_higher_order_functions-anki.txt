Polymorphic <tt>list</tt> can be thought of as what?	- A function from <tt>Type</tt>s to <tt>Inductive</tt> definitions.<br>- A function from <tt>Types</tt> to <tt>Types</tt>.
How are polymorphic types written?	With the type parameters following the bare name of the datatype.<br>E.g., <tt>list nat</tt> or <tt>list X</tt>.
What are the types of the <em>polymorphic constructors</em> <tt>nil</tt> and <tt>cons</tt>?	<pre>Check nil.<br>===> nil : forall X : Type, list X<br>Check cons.<br>===> cons : forall X : Type, X -> list X -> list X</pre>
How should <tt>forall X</tt> be read in the type of a polymorphic constructor?	As an additional argument to the constructor that determines the expected types of the arguments that follow.
With respect to polymorphic inductive types, Coq will automatically infer what?<br><br>What won't Coq automatically infer?	Coq will automatically attempt to infer the type of an arguments, even if that type is <tt>Type</tt>.<br><br>However, Coq won't automatically attempt to infer <em>arguments</em>, for example to the type parameters of a polymorphic constructor.
When no inference has been requested, where do you write type argument in a constructor invocation?<br><br>How about in a constructor that is a case of a match on a polymorphic datatype?	You provide the type argument when invoking a polymorphic constructor.<br><br>You do not provide the type argument to a polymorphic constructors in a match on a polymorphic datatype. This is because the polymorphic parameter belongs to the datatype as a whole, not to its constructors.
Underscores can replace what kinds of type information?	- They can replace type annotations. Of course, you could also simply omit the annotation altogether.<br>- They can replace type arguments demanded by polymorphic constructors.
How does Coq determine what to fill in for the implicit argument?	Coq attempts to <em>unify</em> all locally available information -- the type of the function being applied, the types of the other arguments, and the type expected by the context in which the application appears -- to determine what concrete type should replace the underscore.
How can type argument inference be requested by a user?	At constructor/function invocation provide the <em>implicit argument</em>:<br><pre>length bool someBoolList<br>length _ someBoolList</pre><br>For the remainder of the module, works on functions or inductive constructors:<br><pre>Implicit Arguments length [[X]].</pre>
How can type argument inference be requested at definition site?<br><br>This does not work on ...	On function declaration site use curlies, which avoids even the need for underscores on use-site:<br><pre>Fixpoint length {X:Type} (l:list X) : nat :=<br>  ...</pre><br>... inductive definitions.
What is the limit of implicit arguments?	Even after an <tt>Implicit Argument</tt> statement there will be cases Coq cannot figure out the right argument. In those cases you can use <tt>@</tt> and provide the type argument explicitly or intentionally omit it without Coq attempting to fill it in.<br><br><pre>(* This fails if inference has been requested.*)<br>(* Check nil. *)<br><br>Check @nil.<br>Check @nil nat.</pre>
What's the difference between <tt>(x,y)</tt> and <tt>(X*Y)</tt>?	<tt>(x,y)</tt> is a 2-tuple <em>value</em>, using special notation.<br><tt>(X*Y)</tt> is its <em>type</em>, also using special notation.<br><br>It just so happens that <tt>x:X</tt> and <tt>y:Y</tt>.
What is <tt>type_scope</tt>?	The scope used when Coq is parsing symbols. Notations for types, like <tt>X*Y</tt> will be declared in <tt>type_scope</tt>, in this case to avoid clash with multiplication.
Matching on multiple arguments is actually what?	Matching on a single product argument, with the parens ommitted.
Which way does the type arrow associate?	Right.<br><br>The following two are equivalent:<br><pre>nat -> nat -><br>nat -> (nat -> nat)</pre>
What is the partial application syntax?	Simply omit arguments in an invocation.
What are the types of the currying and uncurrying a function?	Currying:<br><pre>forall X Y Z : Type, (X * Y -> Z) -> X -> Y -> Z</pre><br>Uncurrying:<br><pre>forall X Y Z : Type, (X -> Y -> Z) -> X * Y -> Z</pre>
Give the syntax of anonymous functions.	<pre>fun arg1 ... argN => expr</pre>
What is the type of the <tt>override</tt> function?	<pre>forall X : Type, (nat -> X) -> nat -> X -> nat -> X</pre>
Describe the <tt>unfold</tt> and <tt>fold</tt> tactics.	<tt>unfold</tt> replaces a term with its definition, "expanding" functions.<br><br><tt>fold</tt> takes the expanded term and packs it back up into a definition. It is much less used.
What does it mean to say that constructors in Coq are <em>disjoint</em>?	Values built from distinct constructors are never equal.
What does it mean to say that constructors in Coq are <em>injective</em>?	The only way for two values produced by a constructor to be equal is for them to have been constructed with the same values as functions.
Describe the <tt>inversion</tt> tactic.	Given a hypothesis <tt>H</tt> in context or previously proven:<br><pre>c a1 ... an = d b1 ... bn</pre><br><tt>inversion H</tt> will conclude either:<br>- If <tt>c</tt> and  <tt>d</tt> are the same constructor then by the inversion property <tt>ai = bi</tt>. Those facts will be added to the context and will be used to rewrite the goal.<br><br>- If <tt>c</tt> and <tt>d</tt> are different then by disjointness property we have reached contradiction so the current goal is proved, since <em>any</em> goal is now provable.
<tt>inversion</tt> can act on what?	Equations involving simple constructor values or even complex terms like lists.
How can tactics be applied to hypothesis instead of the goal?	Use the <tt>in</tt> keyword.<br><br>For example:<br><pre>simpl in H<br>apply L in H</pre>
Describe the difference between <tt>apply</tt> and <tt>apply...in</tt>.	<tt>apply L in H</tt> uses forward reasoning, matching <tt>H</tt> against the premise of <tt>L</tt>, replacing <tt>H</tt> with the conclusion of <tt>L</tt>.<br><br><tt>apply L</tt> however matches the current goal against the <em>conclusion</em> of <tt>L</tt>, ending the current goal and creating new goals for each premise of <tt>L</tt>.
Explain the difference between <em>forward</em> and <em>backward</em> reasoning.	Forward reasoning is just modus ponens:<br>Given <tt>L1</tt> and <tt>L1->L2</tt> conclude <tt>L2</tt>.<br>Backward reasoning starts with the goal and reasons about what would imply the goal until a premise or previous theorem is reached.<br>Given <tt>L1->L2</tt> and the <em>goal</em> <tt>L2</tt>, consider it we can establish <tt>L1</tt>.
What happens if you <tt>destruct</tt> on an expression instead of a value?	The cases will be equations with the expression and its possible values, one per constructor.<br><br><pre>destruct (beq_nat n 3).<br>  Case "beq_nat n 3 = true". ...<br>  Case "beq_nat n 3 = false". ...</pre>
Explain the <tt>remember</tt> tactic.	<pre>remember (expr) as name.</pre><br><tt>name</tt> will be added to context along with a new assumption <tt>name=expr</tt>. Further, instances of <tt>expr</tt> will be replaced with <tt>name</tt>.
What is a common use-case for <tt>remember</tt>?	The substitution done by <tt>destruct</tt> (i.e., substituting instances of the destructed expression with the current possible value) eradicates information needed for the proof.
Explain the <tt>apply ... with ...</tt> tactic.	Sometimes when you do <tt>apply H</tt> Coq is not able to bind every variable in <tt>H</tt> to the goal, perhaps because some variables don't apply in the conclusion of <tt>H</tt>, only in the premises.<br>This tactic provides a way to explicitly give Coq bindings between <tt>H</tt> and the goal.<br><br><pre>apply trans_eq with (m:=[c,d]).</pre>That binds the variable <tt>m</tt> to the list <tt>[c,d]</tt>.
