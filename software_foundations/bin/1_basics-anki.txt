Where does Coq define booleans and numbers?	In the standard library.
What's a "type" in Coq?	A set of data values.
As an example of an enumerated type, define the boolean type.	<pre>Inductive bool : Type :=<br>  | true : bool<br>  | false : bool.</pre>
Define a boolean negation function.	<pre>Definition negb (b : bool) : bool :=<br>  match b with<br>  | true => false<br>  | false => true<br>  end.</pre>
Define a function for boolean conjunction.	<pre>Definition andb (b1:bool) (b2:bool) : bool :=<br>  match b1 with<br>  | true => b2<br>  | false => false<br>  end.</pre>
Make a named assertion that ~<tt>true</tt> is <tt>false</tt>, then prove it.	<pre>Example test_negation:<br>  (negb true) = false.<br>Proof. simpl. reflexivity. Qed.</pre>
Name three ways to check that a function works.	- Use <tt>Eval</tt> on a test case and observe the result.<br>- Use <tt>Example</tt>/<tt>Theorem</tt>/whatever to record expected result, then as Coq to verify.<br>- "extract" function <tt>Definition</tt> to OCaml, Scheme, or Haskell.
Apply negation to the boolean <tt>true</tt>.	<tt>Eval simpl in (negb true).</tt>
What are Coq's names for boolean and/or/not?	- <tt>andb</tt><br>- <tt>orb</tt><br>- <tt>negb</tt>
How do you fill in a hole in a <tt>Definition</tt>? In an <tt>Example</tt>?	<tt>admit</tt> fills in holes in <tt>Definitions</tt>.<br><tt>Admitted</tt> fills in holes in proofs.
How does Coq write the type of a boolean conjunction function?	<tt>bool->bool->bool</tt>
What does the <tt>Check</tt> command do?	It causes Coq to print the type of an expression.
How will we use the module system?	If you put declarations between <tt>Module X</tt> and <tt>End X</tt> then after <tt>End</tt> the definitions are referred to as <tt>X.foo</tt>.
As an example of a type with a sum constructor, define <tt>nat</tt>.	<pre>Inductive nat : Type :=<br>  | O : nat<br>  | S : nat -> nat.</pre>
When we use <tt>Inductive</tt> to define a type, we should see it as what?	A set of <em>expressions</em>, inductively defined. The definition tells us exactly how members of the type can be constructed, and excludes all other expressions.
What is the fundamental difference between a data constructor and and functions?	Functions come with <em>computation rules</em>. Data constructors have no behavior attached.
Name some keywords that can introduce a function.	- <tt>Definition</tt><br>- <tt>Fixpoint</tt> in case of recursion
What kind of recursion does Coq allow?	<em>Structural</em> (or <em>primitive</em>) recursion. That means recursive calls must be on strictly smaller values, guaranteeing termination.
What notational convenience does Coq provide for multiple parameters of the same type?	The following are equivalent:<br><br><pre>(n m : nat)<br>(n: nat) (m: nat)</pre>
How does one match on <em>multiple</em> expressions?	A comma is placed between then in the scrutinee and between the two sides of each matching pattern.
How is "language support" introduced for some definitions?<br><br>Name two kinds of language support available.	With <tt>Notation</tt> constructions which also define associativity and precedence.<br><br>- Numerals<br>- Operators<br>- Collections syntax
How can one choose between multiple notation interpretations for an expression.	<pre>expression%notation_scope</pre>
Which tactic is like <tt>simpl</tt> "on steroids"?	<tt>compute</tt>
The <tt>reflexivity</tt> tactic implicitly does what?<br><br>What's the difference between the simplification of <tt>simpl</tt> and that of <tt>reflexivity</tt>?	Simplifies both sides before testing (including by using <tt>simpl</tt>).<br><br>Among other things, <tt>reflexivity</tt> may expand definitions. <tt>simpl</tt> never will.
What does the <tt>intros</tt> tactic do?	For a conditional it introduces the antecedent as an assumption. For a universally quantified statement it introduces an arbitrary element of the domain and discharges the quantifier.
What is the syntax of <tt>intros</tt>?	The keyword <tt>intros</tt> followed by a space-delimited list of names for the assumptions. These may be names of variables already in context, or they may be ones you're <em>introducing</em>. The names are interpreted in the order the relevant expressions appear in the current context.
Describe the <tt>rewrite</tt> tactic.<br><br>What does rewriting <em>left-to-write</em> mean?	It rewrites the current goal using the provided rule and in the provided direction.<br><br>For example:<br><pre>rewrite -> H</pre><br>Left-to-write means rewriting the terms in the subgoal that match the left-hand-side of the rule being used.
How are are propositions with multiple hypothesis written?	<pre>Hyp1 -> ... -> HypN -> Conclusion</pre>
Why doesn't simplification be used to prove all theorems?	Unknown values may appear as arguments to functions, preventing simplification.
Give the syntax of the <tt>destruct</tt> tactic.	<pre>destruct var as [pattern].</pre><br><tt>as [pattern]</tt> is optional.<br><br>The pattern consists of names for the data of the possible data constructors of <tt>var</tt> separated by <tt>|</tt>.<br>For a nullary constructor just put the pipe.
Why don't we say <tt>destruct b as [true | false].</tt>?	Remember, the <tt>as</tt> pattern in a <tt>destruct</tt>/<tt>induction</tt> is for the <strong>data</strong> associated with a constructor. Nullary constructors (<em>values</em>) have none.<br>So you would write either of these two:<br><pre>destruct b as [|].<br>destruct b.</pre>
<tt>destruct</tt> proves a theorem about an enumerated type for each possible ...	... constructor used to create that type.
Don't confused <tt>case</tt> with ...	... our hack <tt>Case</tt> and <tt>SCase</tt>.
What is the syntax of the <tt>induction</tt> tactic?	Just the same as the <tt>destruct</tt> tactic.
How can you create sub-theorems without creating a new top-level name?	Use the <tt>assert</tt> tactic.<br><br><pre>assert (H: whatever).<br>  Case "Proof of assertion". whatever.</pre>
What is a common non-stylistic reason for using <tt>assert</tt>?	Coq is choosing the wrong instance of a pattern to rewrite when you use the <tt>rewrite</tt> tactic.<br>In this case you can prove as a sub-theorem exactly the rewrite you want, and then use <tt>rewrite</tt> in terms of this sub-theorem.
